// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: openmatch/frontend.proto

package openmatchconnect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	openmatch "github.com/castaneai/minimatch/gen/openmatch"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// FrontendServiceName is the fully-qualified name of the FrontendService service.
	FrontendServiceName = "openmatch.FrontendService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// FrontendServiceCreateTicketProcedure is the fully-qualified name of the FrontendService's
	// CreateTicket RPC.
	FrontendServiceCreateTicketProcedure = "/openmatch.FrontendService/CreateTicket"
	// FrontendServiceDeleteTicketProcedure is the fully-qualified name of the FrontendService's
	// DeleteTicket RPC.
	FrontendServiceDeleteTicketProcedure = "/openmatch.FrontendService/DeleteTicket"
	// FrontendServiceGetTicketProcedure is the fully-qualified name of the FrontendService's GetTicket
	// RPC.
	FrontendServiceGetTicketProcedure = "/openmatch.FrontendService/GetTicket"
	// FrontendServiceWatchAssignmentsProcedure is the fully-qualified name of the FrontendService's
	// WatchAssignments RPC.
	FrontendServiceWatchAssignmentsProcedure = "/openmatch.FrontendService/WatchAssignments"
	// FrontendServiceAcknowledgeBackfillProcedure is the fully-qualified name of the FrontendService's
	// AcknowledgeBackfill RPC.
	FrontendServiceAcknowledgeBackfillProcedure = "/openmatch.FrontendService/AcknowledgeBackfill"
	// FrontendServiceCreateBackfillProcedure is the fully-qualified name of the FrontendService's
	// CreateBackfill RPC.
	FrontendServiceCreateBackfillProcedure = "/openmatch.FrontendService/CreateBackfill"
	// FrontendServiceDeleteBackfillProcedure is the fully-qualified name of the FrontendService's
	// DeleteBackfill RPC.
	FrontendServiceDeleteBackfillProcedure = "/openmatch.FrontendService/DeleteBackfill"
	// FrontendServiceGetBackfillProcedure is the fully-qualified name of the FrontendService's
	// GetBackfill RPC.
	FrontendServiceGetBackfillProcedure = "/openmatch.FrontendService/GetBackfill"
	// FrontendServiceUpdateBackfillProcedure is the fully-qualified name of the FrontendService's
	// UpdateBackfill RPC.
	FrontendServiceUpdateBackfillProcedure = "/openmatch.FrontendService/UpdateBackfill"
)

// These variables are the protoreflect.Descriptor objects for the RPCs defined in this package.
var (
	frontendServiceServiceDescriptor                   = openmatch.File_openmatch_frontend_proto.Services().ByName("FrontendService")
	frontendServiceCreateTicketMethodDescriptor        = frontendServiceServiceDescriptor.Methods().ByName("CreateTicket")
	frontendServiceDeleteTicketMethodDescriptor        = frontendServiceServiceDescriptor.Methods().ByName("DeleteTicket")
	frontendServiceGetTicketMethodDescriptor           = frontendServiceServiceDescriptor.Methods().ByName("GetTicket")
	frontendServiceWatchAssignmentsMethodDescriptor    = frontendServiceServiceDescriptor.Methods().ByName("WatchAssignments")
	frontendServiceAcknowledgeBackfillMethodDescriptor = frontendServiceServiceDescriptor.Methods().ByName("AcknowledgeBackfill")
	frontendServiceCreateBackfillMethodDescriptor      = frontendServiceServiceDescriptor.Methods().ByName("CreateBackfill")
	frontendServiceDeleteBackfillMethodDescriptor      = frontendServiceServiceDescriptor.Methods().ByName("DeleteBackfill")
	frontendServiceGetBackfillMethodDescriptor         = frontendServiceServiceDescriptor.Methods().ByName("GetBackfill")
	frontendServiceUpdateBackfillMethodDescriptor      = frontendServiceServiceDescriptor.Methods().ByName("UpdateBackfill")
)

// FrontendServiceClient is a client for the openmatch.FrontendService service.
type FrontendServiceClient interface {
	CreateTicket(context.Context, *connect.Request[openmatch.CreateTicketRequest]) (*connect.Response[openmatch.Ticket], error)
	DeleteTicket(context.Context, *connect.Request[openmatch.DeleteTicketRequest]) (*connect.Response[emptypb.Empty], error)
	GetTicket(context.Context, *connect.Request[openmatch.GetTicketRequest]) (*connect.Response[openmatch.Ticket], error)
	WatchAssignments(context.Context, *connect.Request[openmatch.WatchAssignmentsRequest]) (*connect.ServerStreamForClient[openmatch.WatchAssignmentsResponse], error)
	AcknowledgeBackfill(context.Context, *connect.Request[openmatch.AcknowledgeBackfillRequest]) (*connect.Response[openmatch.AcknowledgeBackfillResponse], error)
	CreateBackfill(context.Context, *connect.Request[openmatch.CreateBackfillRequest]) (*connect.Response[openmatch.Backfill], error)
	DeleteBackfill(context.Context, *connect.Request[openmatch.DeleteBackfillRequest]) (*connect.Response[emptypb.Empty], error)
	GetBackfill(context.Context, *connect.Request[openmatch.GetBackfillRequest]) (*connect.Response[openmatch.Backfill], error)
	UpdateBackfill(context.Context, *connect.Request[openmatch.UpdateBackfillRequest]) (*connect.Response[openmatch.Backfill], error)
}

// NewFrontendServiceClient constructs a client for the openmatch.FrontendService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewFrontendServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) FrontendServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &frontendServiceClient{
		createTicket: connect.NewClient[openmatch.CreateTicketRequest, openmatch.Ticket](
			httpClient,
			baseURL+FrontendServiceCreateTicketProcedure,
			connect.WithSchema(frontendServiceCreateTicketMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		deleteTicket: connect.NewClient[openmatch.DeleteTicketRequest, emptypb.Empty](
			httpClient,
			baseURL+FrontendServiceDeleteTicketProcedure,
			connect.WithSchema(frontendServiceDeleteTicketMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getTicket: connect.NewClient[openmatch.GetTicketRequest, openmatch.Ticket](
			httpClient,
			baseURL+FrontendServiceGetTicketProcedure,
			connect.WithSchema(frontendServiceGetTicketMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		watchAssignments: connect.NewClient[openmatch.WatchAssignmentsRequest, openmatch.WatchAssignmentsResponse](
			httpClient,
			baseURL+FrontendServiceWatchAssignmentsProcedure,
			connect.WithSchema(frontendServiceWatchAssignmentsMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		acknowledgeBackfill: connect.NewClient[openmatch.AcknowledgeBackfillRequest, openmatch.AcknowledgeBackfillResponse](
			httpClient,
			baseURL+FrontendServiceAcknowledgeBackfillProcedure,
			connect.WithSchema(frontendServiceAcknowledgeBackfillMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		createBackfill: connect.NewClient[openmatch.CreateBackfillRequest, openmatch.Backfill](
			httpClient,
			baseURL+FrontendServiceCreateBackfillProcedure,
			connect.WithSchema(frontendServiceCreateBackfillMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		deleteBackfill: connect.NewClient[openmatch.DeleteBackfillRequest, emptypb.Empty](
			httpClient,
			baseURL+FrontendServiceDeleteBackfillProcedure,
			connect.WithSchema(frontendServiceDeleteBackfillMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getBackfill: connect.NewClient[openmatch.GetBackfillRequest, openmatch.Backfill](
			httpClient,
			baseURL+FrontendServiceGetBackfillProcedure,
			connect.WithSchema(frontendServiceGetBackfillMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		updateBackfill: connect.NewClient[openmatch.UpdateBackfillRequest, openmatch.Backfill](
			httpClient,
			baseURL+FrontendServiceUpdateBackfillProcedure,
			connect.WithSchema(frontendServiceUpdateBackfillMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// frontendServiceClient implements FrontendServiceClient.
type frontendServiceClient struct {
	createTicket        *connect.Client[openmatch.CreateTicketRequest, openmatch.Ticket]
	deleteTicket        *connect.Client[openmatch.DeleteTicketRequest, emptypb.Empty]
	getTicket           *connect.Client[openmatch.GetTicketRequest, openmatch.Ticket]
	watchAssignments    *connect.Client[openmatch.WatchAssignmentsRequest, openmatch.WatchAssignmentsResponse]
	acknowledgeBackfill *connect.Client[openmatch.AcknowledgeBackfillRequest, openmatch.AcknowledgeBackfillResponse]
	createBackfill      *connect.Client[openmatch.CreateBackfillRequest, openmatch.Backfill]
	deleteBackfill      *connect.Client[openmatch.DeleteBackfillRequest, emptypb.Empty]
	getBackfill         *connect.Client[openmatch.GetBackfillRequest, openmatch.Backfill]
	updateBackfill      *connect.Client[openmatch.UpdateBackfillRequest, openmatch.Backfill]
}

// CreateTicket calls openmatch.FrontendService.CreateTicket.
func (c *frontendServiceClient) CreateTicket(ctx context.Context, req *connect.Request[openmatch.CreateTicketRequest]) (*connect.Response[openmatch.Ticket], error) {
	return c.createTicket.CallUnary(ctx, req)
}

// DeleteTicket calls openmatch.FrontendService.DeleteTicket.
func (c *frontendServiceClient) DeleteTicket(ctx context.Context, req *connect.Request[openmatch.DeleteTicketRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.deleteTicket.CallUnary(ctx, req)
}

// GetTicket calls openmatch.FrontendService.GetTicket.
func (c *frontendServiceClient) GetTicket(ctx context.Context, req *connect.Request[openmatch.GetTicketRequest]) (*connect.Response[openmatch.Ticket], error) {
	return c.getTicket.CallUnary(ctx, req)
}

// WatchAssignments calls openmatch.FrontendService.WatchAssignments.
func (c *frontendServiceClient) WatchAssignments(ctx context.Context, req *connect.Request[openmatch.WatchAssignmentsRequest]) (*connect.ServerStreamForClient[openmatch.WatchAssignmentsResponse], error) {
	return c.watchAssignments.CallServerStream(ctx, req)
}

// AcknowledgeBackfill calls openmatch.FrontendService.AcknowledgeBackfill.
func (c *frontendServiceClient) AcknowledgeBackfill(ctx context.Context, req *connect.Request[openmatch.AcknowledgeBackfillRequest]) (*connect.Response[openmatch.AcknowledgeBackfillResponse], error) {
	return c.acknowledgeBackfill.CallUnary(ctx, req)
}

// CreateBackfill calls openmatch.FrontendService.CreateBackfill.
func (c *frontendServiceClient) CreateBackfill(ctx context.Context, req *connect.Request[openmatch.CreateBackfillRequest]) (*connect.Response[openmatch.Backfill], error) {
	return c.createBackfill.CallUnary(ctx, req)
}

// DeleteBackfill calls openmatch.FrontendService.DeleteBackfill.
func (c *frontendServiceClient) DeleteBackfill(ctx context.Context, req *connect.Request[openmatch.DeleteBackfillRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.deleteBackfill.CallUnary(ctx, req)
}

// GetBackfill calls openmatch.FrontendService.GetBackfill.
func (c *frontendServiceClient) GetBackfill(ctx context.Context, req *connect.Request[openmatch.GetBackfillRequest]) (*connect.Response[openmatch.Backfill], error) {
	return c.getBackfill.CallUnary(ctx, req)
}

// UpdateBackfill calls openmatch.FrontendService.UpdateBackfill.
func (c *frontendServiceClient) UpdateBackfill(ctx context.Context, req *connect.Request[openmatch.UpdateBackfillRequest]) (*connect.Response[openmatch.Backfill], error) {
	return c.updateBackfill.CallUnary(ctx, req)
}

// FrontendServiceHandler is an implementation of the openmatch.FrontendService service.
type FrontendServiceHandler interface {
	CreateTicket(context.Context, *connect.Request[openmatch.CreateTicketRequest]) (*connect.Response[openmatch.Ticket], error)
	DeleteTicket(context.Context, *connect.Request[openmatch.DeleteTicketRequest]) (*connect.Response[emptypb.Empty], error)
	GetTicket(context.Context, *connect.Request[openmatch.GetTicketRequest]) (*connect.Response[openmatch.Ticket], error)
	WatchAssignments(context.Context, *connect.Request[openmatch.WatchAssignmentsRequest], *connect.ServerStream[openmatch.WatchAssignmentsResponse]) error
	AcknowledgeBackfill(context.Context, *connect.Request[openmatch.AcknowledgeBackfillRequest]) (*connect.Response[openmatch.AcknowledgeBackfillResponse], error)
	CreateBackfill(context.Context, *connect.Request[openmatch.CreateBackfillRequest]) (*connect.Response[openmatch.Backfill], error)
	DeleteBackfill(context.Context, *connect.Request[openmatch.DeleteBackfillRequest]) (*connect.Response[emptypb.Empty], error)
	GetBackfill(context.Context, *connect.Request[openmatch.GetBackfillRequest]) (*connect.Response[openmatch.Backfill], error)
	UpdateBackfill(context.Context, *connect.Request[openmatch.UpdateBackfillRequest]) (*connect.Response[openmatch.Backfill], error)
}

// NewFrontendServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewFrontendServiceHandler(svc FrontendServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	frontendServiceCreateTicketHandler := connect.NewUnaryHandler(
		FrontendServiceCreateTicketProcedure,
		svc.CreateTicket,
		connect.WithSchema(frontendServiceCreateTicketMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	frontendServiceDeleteTicketHandler := connect.NewUnaryHandler(
		FrontendServiceDeleteTicketProcedure,
		svc.DeleteTicket,
		connect.WithSchema(frontendServiceDeleteTicketMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	frontendServiceGetTicketHandler := connect.NewUnaryHandler(
		FrontendServiceGetTicketProcedure,
		svc.GetTicket,
		connect.WithSchema(frontendServiceGetTicketMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	frontendServiceWatchAssignmentsHandler := connect.NewServerStreamHandler(
		FrontendServiceWatchAssignmentsProcedure,
		svc.WatchAssignments,
		connect.WithSchema(frontendServiceWatchAssignmentsMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	frontendServiceAcknowledgeBackfillHandler := connect.NewUnaryHandler(
		FrontendServiceAcknowledgeBackfillProcedure,
		svc.AcknowledgeBackfill,
		connect.WithSchema(frontendServiceAcknowledgeBackfillMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	frontendServiceCreateBackfillHandler := connect.NewUnaryHandler(
		FrontendServiceCreateBackfillProcedure,
		svc.CreateBackfill,
		connect.WithSchema(frontendServiceCreateBackfillMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	frontendServiceDeleteBackfillHandler := connect.NewUnaryHandler(
		FrontendServiceDeleteBackfillProcedure,
		svc.DeleteBackfill,
		connect.WithSchema(frontendServiceDeleteBackfillMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	frontendServiceGetBackfillHandler := connect.NewUnaryHandler(
		FrontendServiceGetBackfillProcedure,
		svc.GetBackfill,
		connect.WithSchema(frontendServiceGetBackfillMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	frontendServiceUpdateBackfillHandler := connect.NewUnaryHandler(
		FrontendServiceUpdateBackfillProcedure,
		svc.UpdateBackfill,
		connect.WithSchema(frontendServiceUpdateBackfillMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/openmatch.FrontendService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case FrontendServiceCreateTicketProcedure:
			frontendServiceCreateTicketHandler.ServeHTTP(w, r)
		case FrontendServiceDeleteTicketProcedure:
			frontendServiceDeleteTicketHandler.ServeHTTP(w, r)
		case FrontendServiceGetTicketProcedure:
			frontendServiceGetTicketHandler.ServeHTTP(w, r)
		case FrontendServiceWatchAssignmentsProcedure:
			frontendServiceWatchAssignmentsHandler.ServeHTTP(w, r)
		case FrontendServiceAcknowledgeBackfillProcedure:
			frontendServiceAcknowledgeBackfillHandler.ServeHTTP(w, r)
		case FrontendServiceCreateBackfillProcedure:
			frontendServiceCreateBackfillHandler.ServeHTTP(w, r)
		case FrontendServiceDeleteBackfillProcedure:
			frontendServiceDeleteBackfillHandler.ServeHTTP(w, r)
		case FrontendServiceGetBackfillProcedure:
			frontendServiceGetBackfillHandler.ServeHTTP(w, r)
		case FrontendServiceUpdateBackfillProcedure:
			frontendServiceUpdateBackfillHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedFrontendServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedFrontendServiceHandler struct{}

func (UnimplementedFrontendServiceHandler) CreateTicket(context.Context, *connect.Request[openmatch.CreateTicketRequest]) (*connect.Response[openmatch.Ticket], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("openmatch.FrontendService.CreateTicket is not implemented"))
}

func (UnimplementedFrontendServiceHandler) DeleteTicket(context.Context, *connect.Request[openmatch.DeleteTicketRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("openmatch.FrontendService.DeleteTicket is not implemented"))
}

func (UnimplementedFrontendServiceHandler) GetTicket(context.Context, *connect.Request[openmatch.GetTicketRequest]) (*connect.Response[openmatch.Ticket], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("openmatch.FrontendService.GetTicket is not implemented"))
}

func (UnimplementedFrontendServiceHandler) WatchAssignments(context.Context, *connect.Request[openmatch.WatchAssignmentsRequest], *connect.ServerStream[openmatch.WatchAssignmentsResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("openmatch.FrontendService.WatchAssignments is not implemented"))
}

func (UnimplementedFrontendServiceHandler) AcknowledgeBackfill(context.Context, *connect.Request[openmatch.AcknowledgeBackfillRequest]) (*connect.Response[openmatch.AcknowledgeBackfillResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("openmatch.FrontendService.AcknowledgeBackfill is not implemented"))
}

func (UnimplementedFrontendServiceHandler) CreateBackfill(context.Context, *connect.Request[openmatch.CreateBackfillRequest]) (*connect.Response[openmatch.Backfill], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("openmatch.FrontendService.CreateBackfill is not implemented"))
}

func (UnimplementedFrontendServiceHandler) DeleteBackfill(context.Context, *connect.Request[openmatch.DeleteBackfillRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("openmatch.FrontendService.DeleteBackfill is not implemented"))
}

func (UnimplementedFrontendServiceHandler) GetBackfill(context.Context, *connect.Request[openmatch.GetBackfillRequest]) (*connect.Response[openmatch.Backfill], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("openmatch.FrontendService.GetBackfill is not implemented"))
}

func (UnimplementedFrontendServiceHandler) UpdateBackfill(context.Context, *connect.Request[openmatch.UpdateBackfillRequest]) (*connect.Response[openmatch.Backfill], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("openmatch.FrontendService.UpdateBackfill is not implemented"))
}
