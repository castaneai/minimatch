// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: proto/frontend.proto

package protoconnect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	proto "github.com/castaneai/minimatch/pkg/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// FrontendServiceName is the fully-qualified name of the FrontendService service.
	FrontendServiceName = "minimatch.FrontendService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// FrontendServiceCreateTicketProcedure is the fully-qualified name of the FrontendService's
	// CreateTicket RPC.
	FrontendServiceCreateTicketProcedure = "/minimatch.FrontendService/CreateTicket"
	// FrontendServiceDeleteTicketProcedure is the fully-qualified name of the FrontendService's
	// DeleteTicket RPC.
	FrontendServiceDeleteTicketProcedure = "/minimatch.FrontendService/DeleteTicket"
	// FrontendServiceGetTicketProcedure is the fully-qualified name of the FrontendService's GetTicket
	// RPC.
	FrontendServiceGetTicketProcedure = "/minimatch.FrontendService/GetTicket"
	// FrontendServiceWatchAssignmentsProcedure is the fully-qualified name of the FrontendService's
	// WatchAssignments RPC.
	FrontendServiceWatchAssignmentsProcedure = "/minimatch.FrontendService/WatchAssignments"
	// FrontendServiceAcknowledgeBackfillProcedure is the fully-qualified name of the FrontendService's
	// AcknowledgeBackfill RPC.
	FrontendServiceAcknowledgeBackfillProcedure = "/minimatch.FrontendService/AcknowledgeBackfill"
	// FrontendServiceCreateBackfillProcedure is the fully-qualified name of the FrontendService's
	// CreateBackfill RPC.
	FrontendServiceCreateBackfillProcedure = "/minimatch.FrontendService/CreateBackfill"
	// FrontendServiceDeleteBackfillProcedure is the fully-qualified name of the FrontendService's
	// DeleteBackfill RPC.
	FrontendServiceDeleteBackfillProcedure = "/minimatch.FrontendService/DeleteBackfill"
	// FrontendServiceGetBackfillProcedure is the fully-qualified name of the FrontendService's
	// GetBackfill RPC.
	FrontendServiceGetBackfillProcedure = "/minimatch.FrontendService/GetBackfill"
	// FrontendServiceUpdateBackfillProcedure is the fully-qualified name of the FrontendService's
	// UpdateBackfill RPC.
	FrontendServiceUpdateBackfillProcedure = "/minimatch.FrontendService/UpdateBackfill"
)

// FrontendServiceClient is a client for the minimatch.FrontendService service.
type FrontendServiceClient interface {
	CreateTicket(context.Context, *connect_go.Request[proto.CreateTicketRequest]) (*connect_go.Response[proto.Ticket], error)
	DeleteTicket(context.Context, *connect_go.Request[proto.DeleteTicketRequest]) (*connect_go.Response[emptypb.Empty], error)
	GetTicket(context.Context, *connect_go.Request[proto.GetTicketRequest]) (*connect_go.Response[proto.Ticket], error)
	WatchAssignments(context.Context, *connect_go.Request[proto.WatchAssignmentsRequest]) (*connect_go.ServerStreamForClient[proto.WatchAssignmentsResponse], error)
	AcknowledgeBackfill(context.Context, *connect_go.Request[proto.AcknowledgeBackfillRequest]) (*connect_go.Response[proto.AcknowledgeBackfillResponse], error)
	CreateBackfill(context.Context, *connect_go.Request[proto.CreateBackfillRequest]) (*connect_go.Response[proto.Backfill], error)
	DeleteBackfill(context.Context, *connect_go.Request[proto.DeleteBackfillRequest]) (*connect_go.Response[emptypb.Empty], error)
	GetBackfill(context.Context, *connect_go.Request[proto.GetBackfillRequest]) (*connect_go.Response[proto.Backfill], error)
	UpdateBackfill(context.Context, *connect_go.Request[proto.UpdateBackfillRequest]) (*connect_go.Response[proto.Backfill], error)
}

// NewFrontendServiceClient constructs a client for the minimatch.FrontendService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewFrontendServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) FrontendServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &frontendServiceClient{
		createTicket: connect_go.NewClient[proto.CreateTicketRequest, proto.Ticket](
			httpClient,
			baseURL+FrontendServiceCreateTicketProcedure,
			opts...,
		),
		deleteTicket: connect_go.NewClient[proto.DeleteTicketRequest, emptypb.Empty](
			httpClient,
			baseURL+FrontendServiceDeleteTicketProcedure,
			opts...,
		),
		getTicket: connect_go.NewClient[proto.GetTicketRequest, proto.Ticket](
			httpClient,
			baseURL+FrontendServiceGetTicketProcedure,
			opts...,
		),
		watchAssignments: connect_go.NewClient[proto.WatchAssignmentsRequest, proto.WatchAssignmentsResponse](
			httpClient,
			baseURL+FrontendServiceWatchAssignmentsProcedure,
			opts...,
		),
		acknowledgeBackfill: connect_go.NewClient[proto.AcknowledgeBackfillRequest, proto.AcknowledgeBackfillResponse](
			httpClient,
			baseURL+FrontendServiceAcknowledgeBackfillProcedure,
			opts...,
		),
		createBackfill: connect_go.NewClient[proto.CreateBackfillRequest, proto.Backfill](
			httpClient,
			baseURL+FrontendServiceCreateBackfillProcedure,
			opts...,
		),
		deleteBackfill: connect_go.NewClient[proto.DeleteBackfillRequest, emptypb.Empty](
			httpClient,
			baseURL+FrontendServiceDeleteBackfillProcedure,
			opts...,
		),
		getBackfill: connect_go.NewClient[proto.GetBackfillRequest, proto.Backfill](
			httpClient,
			baseURL+FrontendServiceGetBackfillProcedure,
			opts...,
		),
		updateBackfill: connect_go.NewClient[proto.UpdateBackfillRequest, proto.Backfill](
			httpClient,
			baseURL+FrontendServiceUpdateBackfillProcedure,
			opts...,
		),
	}
}

// frontendServiceClient implements FrontendServiceClient.
type frontendServiceClient struct {
	createTicket        *connect_go.Client[proto.CreateTicketRequest, proto.Ticket]
	deleteTicket        *connect_go.Client[proto.DeleteTicketRequest, emptypb.Empty]
	getTicket           *connect_go.Client[proto.GetTicketRequest, proto.Ticket]
	watchAssignments    *connect_go.Client[proto.WatchAssignmentsRequest, proto.WatchAssignmentsResponse]
	acknowledgeBackfill *connect_go.Client[proto.AcknowledgeBackfillRequest, proto.AcknowledgeBackfillResponse]
	createBackfill      *connect_go.Client[proto.CreateBackfillRequest, proto.Backfill]
	deleteBackfill      *connect_go.Client[proto.DeleteBackfillRequest, emptypb.Empty]
	getBackfill         *connect_go.Client[proto.GetBackfillRequest, proto.Backfill]
	updateBackfill      *connect_go.Client[proto.UpdateBackfillRequest, proto.Backfill]
}

// CreateTicket calls minimatch.FrontendService.CreateTicket.
func (c *frontendServiceClient) CreateTicket(ctx context.Context, req *connect_go.Request[proto.CreateTicketRequest]) (*connect_go.Response[proto.Ticket], error) {
	return c.createTicket.CallUnary(ctx, req)
}

// DeleteTicket calls minimatch.FrontendService.DeleteTicket.
func (c *frontendServiceClient) DeleteTicket(ctx context.Context, req *connect_go.Request[proto.DeleteTicketRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.deleteTicket.CallUnary(ctx, req)
}

// GetTicket calls minimatch.FrontendService.GetTicket.
func (c *frontendServiceClient) GetTicket(ctx context.Context, req *connect_go.Request[proto.GetTicketRequest]) (*connect_go.Response[proto.Ticket], error) {
	return c.getTicket.CallUnary(ctx, req)
}

// WatchAssignments calls minimatch.FrontendService.WatchAssignments.
func (c *frontendServiceClient) WatchAssignments(ctx context.Context, req *connect_go.Request[proto.WatchAssignmentsRequest]) (*connect_go.ServerStreamForClient[proto.WatchAssignmentsResponse], error) {
	return c.watchAssignments.CallServerStream(ctx, req)
}

// AcknowledgeBackfill calls minimatch.FrontendService.AcknowledgeBackfill.
func (c *frontendServiceClient) AcknowledgeBackfill(ctx context.Context, req *connect_go.Request[proto.AcknowledgeBackfillRequest]) (*connect_go.Response[proto.AcknowledgeBackfillResponse], error) {
	return c.acknowledgeBackfill.CallUnary(ctx, req)
}

// CreateBackfill calls minimatch.FrontendService.CreateBackfill.
func (c *frontendServiceClient) CreateBackfill(ctx context.Context, req *connect_go.Request[proto.CreateBackfillRequest]) (*connect_go.Response[proto.Backfill], error) {
	return c.createBackfill.CallUnary(ctx, req)
}

// DeleteBackfill calls minimatch.FrontendService.DeleteBackfill.
func (c *frontendServiceClient) DeleteBackfill(ctx context.Context, req *connect_go.Request[proto.DeleteBackfillRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.deleteBackfill.CallUnary(ctx, req)
}

// GetBackfill calls minimatch.FrontendService.GetBackfill.
func (c *frontendServiceClient) GetBackfill(ctx context.Context, req *connect_go.Request[proto.GetBackfillRequest]) (*connect_go.Response[proto.Backfill], error) {
	return c.getBackfill.CallUnary(ctx, req)
}

// UpdateBackfill calls minimatch.FrontendService.UpdateBackfill.
func (c *frontendServiceClient) UpdateBackfill(ctx context.Context, req *connect_go.Request[proto.UpdateBackfillRequest]) (*connect_go.Response[proto.Backfill], error) {
	return c.updateBackfill.CallUnary(ctx, req)
}

// FrontendServiceHandler is an implementation of the minimatch.FrontendService service.
type FrontendServiceHandler interface {
	CreateTicket(context.Context, *connect_go.Request[proto.CreateTicketRequest]) (*connect_go.Response[proto.Ticket], error)
	DeleteTicket(context.Context, *connect_go.Request[proto.DeleteTicketRequest]) (*connect_go.Response[emptypb.Empty], error)
	GetTicket(context.Context, *connect_go.Request[proto.GetTicketRequest]) (*connect_go.Response[proto.Ticket], error)
	WatchAssignments(context.Context, *connect_go.Request[proto.WatchAssignmentsRequest], *connect_go.ServerStream[proto.WatchAssignmentsResponse]) error
	AcknowledgeBackfill(context.Context, *connect_go.Request[proto.AcknowledgeBackfillRequest]) (*connect_go.Response[proto.AcknowledgeBackfillResponse], error)
	CreateBackfill(context.Context, *connect_go.Request[proto.CreateBackfillRequest]) (*connect_go.Response[proto.Backfill], error)
	DeleteBackfill(context.Context, *connect_go.Request[proto.DeleteBackfillRequest]) (*connect_go.Response[emptypb.Empty], error)
	GetBackfill(context.Context, *connect_go.Request[proto.GetBackfillRequest]) (*connect_go.Response[proto.Backfill], error)
	UpdateBackfill(context.Context, *connect_go.Request[proto.UpdateBackfillRequest]) (*connect_go.Response[proto.Backfill], error)
}

// NewFrontendServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewFrontendServiceHandler(svc FrontendServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(FrontendServiceCreateTicketProcedure, connect_go.NewUnaryHandler(
		FrontendServiceCreateTicketProcedure,
		svc.CreateTicket,
		opts...,
	))
	mux.Handle(FrontendServiceDeleteTicketProcedure, connect_go.NewUnaryHandler(
		FrontendServiceDeleteTicketProcedure,
		svc.DeleteTicket,
		opts...,
	))
	mux.Handle(FrontendServiceGetTicketProcedure, connect_go.NewUnaryHandler(
		FrontendServiceGetTicketProcedure,
		svc.GetTicket,
		opts...,
	))
	mux.Handle(FrontendServiceWatchAssignmentsProcedure, connect_go.NewServerStreamHandler(
		FrontendServiceWatchAssignmentsProcedure,
		svc.WatchAssignments,
		opts...,
	))
	mux.Handle(FrontendServiceAcknowledgeBackfillProcedure, connect_go.NewUnaryHandler(
		FrontendServiceAcknowledgeBackfillProcedure,
		svc.AcknowledgeBackfill,
		opts...,
	))
	mux.Handle(FrontendServiceCreateBackfillProcedure, connect_go.NewUnaryHandler(
		FrontendServiceCreateBackfillProcedure,
		svc.CreateBackfill,
		opts...,
	))
	mux.Handle(FrontendServiceDeleteBackfillProcedure, connect_go.NewUnaryHandler(
		FrontendServiceDeleteBackfillProcedure,
		svc.DeleteBackfill,
		opts...,
	))
	mux.Handle(FrontendServiceGetBackfillProcedure, connect_go.NewUnaryHandler(
		FrontendServiceGetBackfillProcedure,
		svc.GetBackfill,
		opts...,
	))
	mux.Handle(FrontendServiceUpdateBackfillProcedure, connect_go.NewUnaryHandler(
		FrontendServiceUpdateBackfillProcedure,
		svc.UpdateBackfill,
		opts...,
	))
	return "/minimatch.FrontendService/", mux
}

// UnimplementedFrontendServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedFrontendServiceHandler struct{}

func (UnimplementedFrontendServiceHandler) CreateTicket(context.Context, *connect_go.Request[proto.CreateTicketRequest]) (*connect_go.Response[proto.Ticket], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("minimatch.FrontendService.CreateTicket is not implemented"))
}

func (UnimplementedFrontendServiceHandler) DeleteTicket(context.Context, *connect_go.Request[proto.DeleteTicketRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("minimatch.FrontendService.DeleteTicket is not implemented"))
}

func (UnimplementedFrontendServiceHandler) GetTicket(context.Context, *connect_go.Request[proto.GetTicketRequest]) (*connect_go.Response[proto.Ticket], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("minimatch.FrontendService.GetTicket is not implemented"))
}

func (UnimplementedFrontendServiceHandler) WatchAssignments(context.Context, *connect_go.Request[proto.WatchAssignmentsRequest], *connect_go.ServerStream[proto.WatchAssignmentsResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("minimatch.FrontendService.WatchAssignments is not implemented"))
}

func (UnimplementedFrontendServiceHandler) AcknowledgeBackfill(context.Context, *connect_go.Request[proto.AcknowledgeBackfillRequest]) (*connect_go.Response[proto.AcknowledgeBackfillResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("minimatch.FrontendService.AcknowledgeBackfill is not implemented"))
}

func (UnimplementedFrontendServiceHandler) CreateBackfill(context.Context, *connect_go.Request[proto.CreateBackfillRequest]) (*connect_go.Response[proto.Backfill], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("minimatch.FrontendService.CreateBackfill is not implemented"))
}

func (UnimplementedFrontendServiceHandler) DeleteBackfill(context.Context, *connect_go.Request[proto.DeleteBackfillRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("minimatch.FrontendService.DeleteBackfill is not implemented"))
}

func (UnimplementedFrontendServiceHandler) GetBackfill(context.Context, *connect_go.Request[proto.GetBackfillRequest]) (*connect_go.Response[proto.Backfill], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("minimatch.FrontendService.GetBackfill is not implemented"))
}

func (UnimplementedFrontendServiceHandler) UpdateBackfill(context.Context, *connect_go.Request[proto.UpdateBackfillRequest]) (*connect_go.Response[proto.Backfill], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("minimatch.FrontendService.UpdateBackfill is not implemented"))
}
